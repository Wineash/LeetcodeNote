# 链表

## 常用方法汇总

- 虚拟头节点、链表拼接（基础）
- 堆排序或称为优先队列（排序题）
- 双指针（一次遍历问题）
- 快慢指针（不规则链表比如环或者相交，一次遍历问题）
- 递归倒序遍历、递归反转(链表反转问题，栈不太常用)

## 例题题解

### No.21 [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

关键词：虚拟头节点，链表拼接

![image-20230328200806722](E:\Study\Leetcode\note\image\image-20230328200806722-16801570762741.png)

```
1. 判断临界条件，非空（用头节点就可以避免）。  
2. 较小的节点作为头节点，并设置尾节点。  
3. 在while循环中不断取较小节点追加到尾节点。直至有一个list为空。  
4. 将非空list接到尾节点  
```

### No.86 [分隔链表](https://leetcode.cn/problems/partition-list/)

关键词：链表拼接

![image-20230328201755015](E:\Study\Leetcode\note\image\image-20230328201755015-16801570762742.png)

```
首次思路

1. 先遍历一边链表，确认分割点的位置，以及它的前节点 
2. 第二次遍历前,设置flag（ifLeft）来确定是否已经经过分割点
3.  开始第二次遍历，在遇到分割点前找比分割点大的值放到分割点后；遇到分割点变更flag（ifLeft），且continue；遇到分割点后把分割点小的值放在分割点的前面。

误区

1. 直接这样做会破坏节点间的相对位置，所以分割点前要用头插法，分割点要用尾插法。实现起来较为麻烦。不如直接将其看作两个子链表。
2. 题目理解错了

优化

1. 声明两个头节点，分别用于存储大于等于分割点和小于等于分割点的链表
2. （先检查参数中，链表是否为空）
3. 遍历链表，按照大小一次用尾插法放入对应的俩链表
4. 两个子链表相连
```

### No.23  [合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

关键词：堆排序

![image-20230328202350451](E:\Study\Leetcode\note\image\image-20230328202350451-16801570762754.png)

```
最初想法（暴力） 时间：n方 空间：1

1. 判断输入的临界条件：链表数组为空。
2. 声明结果res链表和最小节点
3. 在循环中遍历数组，每次遍历初始化两个flag用于记录是否为第一次for循环（以便给空的最小节点赋值）和所有队列已经为空。
4. 遍历数组每个队列的首个元素，并获取最大的节点位置。
5. 第二次遍历，将这个节点位置赋给结果res链表，且节点前进。

易错点：java的链表数组中，用for each声明的节点前进，并不会使lists中的list前进。要用for i和数组下标来进行节点前进才可以。

更有的解决方法-优先级队列（堆排序）-时间：O(Nlogk) 空间：n

1. 声明一个最小堆，堆元素为listNode
2. 将k个链表头节点放入堆中（不是k个链表的所有元素，因为链表本身升序，所以头节点最小即为全部节点最小）
3. 只要堆不为空，就依次执行：最小节点出堆，赋给res，将最小节点的下一个节点（不为空）入堆。
4. k个链表全部为空则结束
```

### No.19  [删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

关键词 ：双指针

![image-20230328203511382](E:\Study\Leetcode\note\image\image-20230328203511382-16801570762756.png)

```
首次思路：双指针 时间：1次遍历 空间：1

1. 首先设置一个遍历指针p用于遍历，在为需要删除的点设置双指针（前置和当前）
2. p先前进次，然后p和双指针一直前进直至p为空
3. 用双指针删除节点，注意当需要删除的节点为首个节点时，直接返回首个链表的下一位。
```

### No.876  [链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

关键词：快慢指针

![image-20230328203831984](E:\Study\Leetcode\note\image\image-20230328203831984-16801570762755.png)

```
优化思路 快慢指针 时间：一次遍历 空间：1

1. 设置两个指针，一个步伐距离为1，一个步伐距离为二。当快指针到终点时，慢指针刚好再链表中间。
2. 注意当链表为单双数时情况不同，也就是快指针的后置位和后后置位情况不同。
```

### No. 141 [环形链表](https://leetcode.cn/problems/linked-list-cycle/)

关键词：快慢指针

![image-20230328204311433](E:\Study\Leetcode\note\image\image-20230328204311433-16801570762753.png)

```
首次解法 双指针 时间：n 空间：1
1. 为链表设置遍历指针和前指针
2. 在循环中不断推进遍历指针和前置指针，同时将前置指针经过的节点的指针改成指向自己的指针
3. 当遍历指针的下一位为空时，即该链表没有环；当指针的下一位为自己时，说明有环。

优化解法 快慢指针 同上
1. 上一个双指针会破坏链表的结构，但一次长度为n的遍历即可完成。采用快慢指针会进行至少一次n+1的遍历
2. 设置步长为1和2的快慢指针
3. 指针不断前进，直至慢指针为空，说明没有环。如果快指针和慢指针重合，则有环
```

### No.160 [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

关键词：栈 快慢指针

![image-20230328204717844](E:\Study\Leetcode\note\image\image-20230328204717844-16801570762757.png)

```
首次解法 利用栈 时间：n 空间：n
1. 利用栈的特性可以轻易地从链表地末尾开始遍历。因此我们先将两个链表放入俩个栈。
2. 两个栈同时不停地出栈，直至出栈地节点不同为止，其后置节点即为所求节点。
3. 注意当首结点为所求节点时，需要略微处理

再次解法 裁剪 时间：n 空间：1
1. 遍历两个链表得到两张表长，得到长度差
2. 较长的链表先走长度差的步数，即可得到两张长度的表
3. 此时即可同时遍历两个链表直至出现相同节点

优化解法 双指针实现拼接的思想 时间：n 空间：1
1. 遍历表a需要numA步，遍历表b需要numB步。在a之后在遍历b，在b之后在遍历a，那么两种遍历需要的部署都是a+b步。
2. 此时两个链表指针就可以同时遍历至链表的尾部.此时同时遍历直至出现相同节点即可

另类解法 转化为求环形链表的环起始点问题 时间：n 空间：1
1. 将两张链表的尾部连接至任意开始节点，即可将提醒转变为环形链表
2. 但破坏了题目中要求的“不能破坏链表结构”的条件，否则这也是一个效率较好的一种解法

小结
1. 这题的思考的方向是 如何使遍历两个链表的重合部分时，其在重合部分的相对位置一致，解决了这个问题就可以轻易的给出题解。
2. 方法一用了栈先入后出的方法，效率较高但是空间占用较高。
3. 方法二使用裁剪使两张表的长度相等，方法三也使用拼接的方法使其相等，但传统的拼接必定会有n的空间占用，这里用双指针前进的方法代替了n的空间占用，非常巧妙。
4. 方法四则用类似辅助线的方式更改了题目的题型，方法巧妙可以不满足题目的限制条件。
```

### No. 206 [反转链表](https://leetcode.cn/problems/reverse-linked-list/) -用递归实现

关键词：递归反转

题目描述：即将一串链表反转

```
递归反转
1. 利用首行递归的特点，可以逐步递归进入最后一个节点，然后逆序一个个操作next节点，使其反转
2. 注意base case即结束条件
```

### No. 92 [反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)-用递归实现

关键词： 递归反转

![image-20230328233550081](E:\Study\Leetcode\note\image\image-20230328233550081.png)

```
1. 和上题思路大致一致。
2. 起始前驱节点和结尾后驱节点需要处理
3. base case即递归的结束条件发生了变化。变成了步数
```

### No. 25  [K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

关键词：递归 迭代 问题划分

![image-20230329165526537](E:\Study\Leetcode\note\image\image-20230329165526537.png)

```
思路：问题分割成子问题，递归和迭代的组合实现
1. 这题思路是非常清晰的，但如果想用递归来优雅的实现则需要注意把握递归的核心思想。 
2. 整体思路无非以k步数的长度，遍历链表。如果满足k则反转子链表，反之则直接返回原子链表的头节点。其中，要注意子链表和子链表的拼接问题
3. 在递归过程中，则只需要专注于此次子链表以及其尾指针指向（有点难理解，最好画图）

反转子链表的迭代函数
1. 之前的反转链表题目都用递归来实现过了，这里为了效率则使用迭代了实现子链表的反转reverse。
2. reverse反转[a，b)的实现是由反转a链表推广而来，其base case是尾指针不为null即[a,null)。更改一下base case即可复用。
3. reverse的范围这里使用了[a,b)乍一看很别扭，但起始b的开区间不仅可以作为base case条件。还能称为下一个子链表的起始节点a。
4. reverse将子链表的尾节点的next置空。注意这里不能直接指向right/b。看似合理，指向了下一个子链表的头节点。殊不知之后下一个子链表被反转后就会称为尾节点。

递归划分链表的递归函数
1. 由于要在每个递归函数中使用反转子链表。所以首先需要准备子链表的a和b。注意b是开区间，因此可以为null，避免落掉数字。
2. 当step不满足步数，直接返回该次递归链表的头接点。反之获得a和b则调用reverse函数获取头节点用于返回。
3. 将置空的尾节点left的next指向下一次递归的返回值，即头节点。注意因为子链表被反转过了，因此是left而不是right，因为此次子链表已经被反转
4. reverseKGroup和reverse的顺序问题，这里有点类似二叉树的先序后序遍历问题，其中reverseKGroup是遍历函数，reverse是我们想执行的输出操作。如果reverseKGroup先执行，则从尾巴往头逐个执行reverse；反之则从头开始执行。
```

### No. 234 [回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

关键词: 递归倒序遍历 /迭代反转链表 快慢指针

![image-20230329185441398](E:\Study\Leetcode\note\image\image-20230329185441398.png)

```
1. 如果完全使用递归倒序遍历的方法可以很轻松简短地完成此题，只需额外设置个全局变量地左指针，配合递归倒序地遍历，即可从两端向中间地比较字符。但由于递归地特性，空间复杂度是n。
2. 另一种方法，先使用快慢指针获得中点，然后已知起点和中点，即可对该区间反转。此时就存在倒序地前半段和正序地后半段，逐个比较即可解决。空间复杂度为1。注意奇书偶数地处理。
```

## 更多题解

### No. 

关键词

### No. 

关键词

### No. 

关键词

### No. 

关键词

### No. 

关键词

### No. 

关键词

### No. 

关键词

### No. 

关键词

### No. 

关键词