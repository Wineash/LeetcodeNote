**思路：问题分割成子问题，递归和迭代的组合实现**
1. 这题思路是非常清晰的，但如果想用递归来优雅的实现则需要注意把握递归的核心思想。 
2. 整体思路无非以k步数的长度，遍历链表。如果满足k则反转子链表，反之则直接返回原子链表的头节点。其中，要注意子链表和子链表的拼接问题
3. 在递归过程中，则只需要专注于此次子链表以及其尾指针指向（有点难理解，最好画图）

**反转子链表的迭代函数**
1. 之前的反转链表题目都用递归来实现过了，这里为了效率则使用迭代了实现子链表的反转reverse。
2. reverse反转[a，b)的实现是由反转a链表推广而来，其base case是尾指针不为null即[a,null)。更改一下base case即可复用。
3. reverse的范围这里使用了[a,b)乍一看很别扭，但起始b的开区间不仅可以作为base case条件。还能称为下一个子链表的起始节点a。
4. reverse将子链表的尾节点的next置空。注意这里不能直接指向right/b。看似合理，指向了下一个子链表的头节点。殊不知之后下一个子链表被反转后就会称为尾节点。

**递归划分链表的递归函数**
1. 由于要在每个递归函数中使用反转子链表。所以首先需要准备子链表的a和b。注意b是开区间，因此可以为null，避免落掉数字。
2. 当step不满足步数，直接返回该次递归链表的头接点。反之获得a和b则调用reverse函数获取头节点用于返回。
3. 将置空的尾节点left的next指向下一次递归的返回值，即头节点。注意因为子链表被反转过了，因此是left而不是right，因为此次子链表已经被反转
4. reverseKGroup和reverse的顺序问题。如果reverseKGroup先执行，则从尾巴往头逐个执行reverse；反之则从头开始执行。