### 首次解法 利用栈 时间：n 空间：n
1. 利用栈的特性可以轻易地从链表地末尾开始遍历。因此我们先将两个链表放入俩个栈。
2. 两个栈同时不停地出栈，直至出栈地节点不同为止，其后置节点即为所求节点。
3. 注意当首结点为所求节点时，需要略微处理

### 再次解法 裁剪 时间：n 空间：1
1. 遍历两个链表得到两张表长，得到长度差
2. 较长的链表先走长度差的步数，即可得到两张长度的表
3. 此时即可同时遍历两个链表直至出现相同节点

### 优化解法 双指针实现拼接的思想 时间：n 空间：1
1. 遍历表a需要numA步，遍历表b需要numB步。在a之后在遍历b，在b之后在遍历a，那么两种遍历需要的部署都是a+b步。
2. 此时两个链表指针就可以同时遍历至链表的尾部.此时同时遍历直至出现相同节点即可

### 另类解法 转化为求环形链表的环起始点问题 时间：n 空间：1
1. 将两张链表的尾部连接至任意开始节点，即可将提醒转变为环形链表
2. 但破坏了题目中要求的“不能破坏链表结构”的条件，否则这也是一个效率较好的一种解法

##### 小结
1. 这题的思考的方向是 如何使遍历两个链表的重合部分时，其在重合部分的相对位置一致，解决了这个问题就可以轻易的给出题解。
2. 方法一用了栈先入后出的方法，效率较高但是空间占用较高。
3. 方法二使用裁剪使两张表的长度相等，方法三也使用拼接的方法使其相等，但传统的拼接必定会有n的空间占用，这里用双指针前进的方法代替了n的空间占用，非常巧妙。
4. 方法四则用类似辅助线的方式更改了题目的题型，方法巧妙可以不满足题目的限制条件。
